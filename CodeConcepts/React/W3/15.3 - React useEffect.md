___

The `useEffect` Hook allows you to perform side effects in your components.

Some examples of side effects are: fetching data, directly updating the DOM, and timers.

`useEffect` accepts two arguments. The second argument is optional.

`useEffect(<function>, <dependency>)`

___

Let's use a timer as an example.

### Example:[Get your own React.js Server](https://www.w3schools.com/spaces/ "W3Schools Spaces")

Use `setTimeout()` to count 1 second after initial render:

    import { useState, useEffect } from "react";
    import ReactDOM from "react-dom/client";
    
    function Timer() {
      const [count, setCount] = useState(0);
    
      useEffect(() => {
        setTimeout(() => {
          setCount((count) => count + 1);
        }, 1000);
      });
    
      return <h1>I've rendered {count} times!</h1>;
    }
    
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<Timer />);

[Run Example »](https://www.w3schools.com/react/showreact.asp?filename=demo2_react_useeffect_settimeout)

But wait!! It keeps counting even though it should only count once!

`useEffect` runs on every render. That means that when the count changes, a render happens, which then triggers another effect.

This is not what we want. There are several ways to control when side effects run.

We should always include the second parameter which accepts an array. We can optionally pass dependencies to `useEffect` in this array.

### Example[Get your own React.js Server](https://www.w3schools.com/spaces/ "W3Schools Spaces")

3\. Props or state values:

    useEffect(() => {
      //Runs on the first render
      //And any time any dependency value changes
    }, [prop, state]);

So, to fix this issue, let's only run this effect on the initial render.

### Example:[Get your own React.js Server](https://www.w3schools.com/spaces/ "W3Schools Spaces")

Only run the effect on the initial render:

    import { useState, useEffect } from "react";
    import ReactDOM from "react-dom/client";
    
    function Timer() {
      const [count, setCount] = useState(0);
    
      useEffect(() => {
        setTimeout(() => {
          setCount((count) => count + 1);
        }, 1000);
      }, []); // <- add empty brackets here
    
      return <h1>I've rendered {count} times!</h1>;
    }
    
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<Timer />);

[Run Example »](https://www.w3schools.com/react/showreact.asp?filename=demo2_react_useeffect_settimeout2)

### Example:[Get your own React.js Server](https://www.w3schools.com/spaces/ "W3Schools Spaces")

Here is an example of a `useEffect` Hook that is dependent on a variable. If the `count` variable updates, the effect will run again:

    import { useState, useEffect } from "react";
    import ReactDOM from "react-dom/client";
    
    function Counter() {
      const [count, setCount] = useState(0);
      const [calculation, setCalculation] = useState(0);
    
      useEffect(() => {
        setCalculation(() => count * 2);
      }, [count]); // <- add the count variable here
    
      return (
        <>
          <p>Count: {count}</p>
          <button onClick={() => setCount((c) => c + 1)}>+</button>
          <p>Calculation: {calculation}</p>
        </>
      );
    }
    
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<Counter />);

[Run Example »](https://www.w3schools.com/react/showreact.asp?filename=demo2_react_useeffect_settimeout3)

If there are multiple dependencies, they should be included in the `useEffect` dependency array.

___

___

## Effect Cleanup

Some effects require cleanup to reduce memory leaks.

Timeouts, subscriptions, event listeners, and other effects that are no longer needed should be disposed.

We do this by including a return function at the end of the `useEffect` Hook.

### Example:[Get your own React.js Server](https://www.w3schools.com/spaces/ "W3Schools Spaces")

Clean up the timer at the end of the `useEffect` Hook:

    import { useState, useEffect } from "react";
    import ReactDOM from "react-dom/client";
    
    function Timer() {
      const [count, setCount] = useState(0);
    
      useEffect(() => {
        let timer = setTimeout(() => {
        setCount((count) => count + 1);
      }, 1000);
    
      return () => clearTimeout(timer)
      }, []);
    
      return <h1>I've rendered {count} times!</h1>;
    }
    
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<Timer />);

[Run Example »](https://www.w3schools.com/react/showreact.asp?filename=demo2_react_useeffect_settimeout_cleanup)

**Note:** To clear the timer, we had to name it.

___

## Test Yourself With Exercises

## Exercise:

What do you need to add to the second argument of a `useEffect` Hook to limit it to running only on the first render?

```
import { useState, useEffect } from "react";
import ReactDOM from "react-dom/client";

function App() {
  const [data, setData] = useState([]);

  useEffect(() => {
    setData(getData())
  }, );

  return <DisplayData data={data} />;
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);

```

[Start the Exercise](https://www.w3schools.com/react/exercise.asp?filename=exercise_useeffect1)

___