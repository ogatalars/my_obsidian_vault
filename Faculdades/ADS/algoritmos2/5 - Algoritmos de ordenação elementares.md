Problemas de ordenação são comuns no desenvolvimento de softwares. Um programa pode gerar ou receber diversos dados ao longo do tempo, precisando constantemente fazer uma consulta em busca de alguns desses. Para facilitar a tarefa da consulta, manter esse conjunto de dados ordenado é uma abordagem comum. Por isso, existe uma série de algoritmos de ordenação, alguns mais simples, como veremos adiante, e outros mais complexos, mas com eficiência superior. Além da importância desses algoritmos para a finalidade a que se propõem, esse tema de estudo é interessante por introduzir o leitor na análise e compreensão de algoritmos mais elaborados, de modo a amadurecer seu raciocínio e sua percepção ao abordar um problema, convertendo-o em um algoritmo e usando as estruturas básicas de programação que já conhece.

Veremos como um mesmo problema – neste caso, o de ordenação – pode ser abordado de diferentes formas: a ordenação pelo método bolha procura posicionar os maiores elementos ao final do vetor; a ordenação por seleção troca um elemento na parte inicial pelo menor elemento que há no restante do vetor a cada iteração; e a ordenação por inserção busca os menores elementos no restante do vetor para posicioná-los ordenadamente no início.

### Ordenação pelo método bolha
A ordenação pelo método bolha, por vezes chamada apenas de ordenação bolha ou, ainda, bubble sort, é um dos métodos mais simples e intuitivos para ordenar elementos em uma lista ou vetor. A lógica empregada neste método é representada pelo seguinte pseudocódigo:

para i = 1 até n faça para j = 0 até n – 2 faça se vetor[ j ] > vetor[ j + 1] então trocar(vetor[ j ], vetor[ j + 1]) fim-se fim-para fim-para

A estratégia consiste em comparar um elemento do vetor com o próximo, iniciando da primeira posição e chegando até a penúltima. Se o próximo elemento for menor, ambos trocarão de posição. O algoritmo repetirá a mesma verificação para todas as próximas posições. Assim, em uma passada pelo vetor (n operações), o maior elemento será alocado na última posição. Essa ação corresponde ao laço interno. Porém é necessário repeti-la n vezes para posicionar corretamente todos os elementos do vetor. Essa ação corresponde ao laço externo.

Como é possível observar, repetir n operações n vezes corresponde a um total de n² operações. Assim, a complexidade desse algoritmo é O(n2 ). No entanto, é possível otimizar dois aspectos: 1. Uma passada pelo vetor sem nenhuma ocorrência de alteração de posição dos elementos indica que ele já está ordenado e, portanto, não é mais necessário repetir essas passadas até um total de n, podendo-se encerrar o algoritmo. 2. Cada passada não precisa percorrer todo o vetor, pois, garantidamente, os últimos elementos estão ordenados; assim, a cada passada, é necessário ir até o elemento anterior ao último ordenado na passada anterior.